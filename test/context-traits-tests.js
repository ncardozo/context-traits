/* Context Traits v0.0.1
   https://github.com/tagae/context-traits
   Copyright © 2012—2014 © 2012—2015 UCLouvain
   Licensed under Apache Licence, Version 2.0 */

// Generated by CoffeeScript 1.3.3
(function() {
  var makeName, noerror;

  noerror = function(block, message) {
    try {
      block.call();
    } catch (error) {
      QUnit.pushFailure(message, null, "Unexpected exception: " + error.message);
      return;
    }
    return QUnit.push(true, null, null, message);
  };

  makeName = function(length) {
    if (length == null) {
      length = 5;
    }
    return Math.random().toString(36).substring(length);
  };

  module("Context Prototypes");

  test("Context", function() {
    ok(typeof Context !== "undefined" && Context !== null, "Context prototype exists.");
    ok($.isFunction(Context), "Context is a (constructor) function.");
    noerror((function() {
      return new Context();
    }), "Contexts can be created.");
    return ok(new Context() instanceof Context, "The `instanceof` operator correctly detects contexts.");
  });

  test("Default context", function() {
    var current;
    ok(contexts.Default != null, "The default context is defined.");
    ok(contexts.Default instanceof Context, "The default context is indeed a context.");
    ok(contexts.Default.isActive(), "The default context is active.");
    current = contexts.Default;
    return strictEqual(current, contexts.Default, "The default context is persistent.");
  });

  module("Context Activation");

  test("Infrastructure", function() {
    ok($.isFunction(Context.prototype.activate), "Method for context activation exists.");
    ok($.isFunction(Context.prototype.deactivate), "Method for context deactivation exists.");
    return ok($.isFunction(Context.prototype.isActive), "Method for context activation state test exists.");
  });

  test("Basic activation", function() {
    var context;
    context = new Context();
    ok(!context.isActive(), "A fresh context is initially inactive.");
    noerror((function() {
      return context.activate();
    }), "Freshly created context can be activated.");
    ok(context.isActive(), "Activation leaves the context in an active state.");
    noerror((function() {
      return context.deactivate();
    }), "Freshly activated context can be deactivated.");
    ok(!context.isActive(), "Deactivation leaves the context in an inactive state.");
    strictEqual(context, context.activate(), "activate() returns the receiver object.");
    return strictEqual(context, context.deactivate(), "deactivate() returns the receiver object.");
  });

  test("Multiple activation", function() {
    var context, n, _i, _j;
    context = new Context();
    for (n = _i = 1; _i <= 10; n = ++_i) {
      context.activate();
    }
    ok(context.isActive(), "A multiply-activated context is active.");
    for (n = _j = 1; _j <= 9; n = ++_j) {
      context.deactivate();
    }
    ok(context.isActive(), "Context stays active for fewer deactivations than activations.");
    context.deactivate();
    return ok(!context.isActive(), "Context becomes inactive after matching number of deactivations.");
  });

  test("Disallowed deactivation", function() {
    var context, n, _i, _j;
    context = new Context();
    throws((function() {
      return context.deactivate();
    }), /cannot.*deactivate.*context/i, "Deactivation of inactive contexts is disallowed.");
    for (n = _i = 1; _i <= 3; n = ++_i) {
      context.activate();
    }
    for (n = _j = 1; _j <= 3; n = ++_j) {
      context.deactivate();
    }
    return throws((function() {
      return context.deactivate();
    }), /cannot.*deactivate.*context/i, "Previous context activity should not interfere with disallowed deactivations.");
  });

  module("Context Adaptation");

  test("Infrastructure", function() {
    return ok($.isFunction(Context.prototype.adapt), "Method to define behavioural adaptations exists.");
  });

  test("Overriding adaptation", function() {
    var noisy, noisyPerson, person;
    person = {
      greet: function() {
        return 'hello';
      },
      toString: function() {
        return 'person';
      }
    };
    noisy = new Context('noisy');
    noisyPerson = Trait({
      greet: function() {
        return 'HELLO';
      }
    });
    noerror((function() {
      return noisy.adapt(person, noisyPerson);
    }), "Definition of a simple adaptation succeeds.");
    equal(person.greet(), 'hello', "Default behaviour is exhibited when context is inactive.");
    noisy.activate();
    equal(person.greet(), 'HELLO', "Adapted behaviour is exhibited after context activation.");
    noisy.deactivate();
    return equal(person.greet(), 'hello', "Default behaviour is exhibited again after context deactivation.");
  });

  test("Adaptation to active context", function() {
    var noisy, noisyPerson, person;
    person = {
      greet: function() {
        return 'hello';
      }
    };
    noisyPerson = Trait({
      greet: function() {
        return 'HELLO';
      }
    });
    noisy = new Context();
    noisy.activate();
    equal(person.greet(), 'hello', "Default behaviour is exhibited prior to introduction of adaptation.");
    noerror((function() {
      return noisy.adapt(person, noisyPerson);
    }), "Adaptation can be introduced in active context.");
    equal(person.greet(), 'HELLO', "Adapted behaviour for active context is observed.");
    noisy.deactivate();
    equal(person.greet(), 'hello', "Default behaviour is persistent.");
    noisy.activate();
    equal(person.greet(), 'HELLO', "Adapted behaviour is persistent.");
    return noisy.deactivate();
  });

  test("Multiple extension", function() {
    var formal, formalGreeter, formalPerson, person;
    person = {
      name: function() {
        return 'Ken';
      },
      greet: function() {
        return 'Hi there';
      }
    };
    formalPerson = Trait({
      name: function() {
        return 'Ken Loach';
      }
    });
    formalGreeter = Trait({
      greet: function() {
        return 'Hello';
      }
    });
    formal = new Context('formal');
    noerror((function() {
      return formal.adapt(person, formalPerson);
    }), "Object can be adapted as usual.");
    noerror((function() {
      return formal.adapt(person, formalGreeter);
    }), "Adaptation of object to same context can be extended with new behaviour.");
    formal.activate();
    equal(person.name(), "Ken Loach", "Original adapted behaviour is exhibited.");
    equal(person.greet(), "Hello", "Additional adapted behaviour is exhibited.");
    return formal.deactivate();
  });

  test("Detection of ambiguous extension", function() {
    var formal, formalPerson, person, veryFormalPerson;
    person = {
      name: function() {
        return 'Ken';
      }
    };
    formalPerson = Trait({
      name: function() {
        return 'Ken Loach';
      }
    });
    veryFormalPerson = Trait({
      name: function() {
        return 'Mr. Ken Loach';
      }
    });
    formal = new Context('formal');
    noerror((function() {
      return formal.adapt(person, formalPerson);
    }), "Method can be adapted to context.");
    return throws((function() {
      return formal.adapt(person, veryFormalPerson);
    }), /property.*already adapted/i, "Rejection of two method definitions for the same context.");
  });

  test("Preservation of receiver identity", function() {
    var formal, formalPerson, person;
    person = {
      name: function() {
        return this.firstName;
      },
      firstName: 'Ken',
      lastName: 'Loach'
    };
    equal(person.name(), "Ken", "Object identity is well-defined in default behaviour.");
    formalPerson = Trait({
      name: function() {
        return this.firstName + ' ' + this.lastName;
      }
    });
    formal = new Context('formal');
    formal.adapt(person, formalPerson);
    equal(person.name(), "Ken", "Object identity is preserved after definition of adaptation.");
    formal.activate();
    equal(person.name(), "Ken Loach", "Object identity is preserved in adapted behaviour.");
    return formal.deactivate();
  });

  test("Adaptation of primitive values", function() {
    var upsideDown, upsideDownNumber;
    upsideDown = new Context();
    upsideDownNumber = Trait({
      "+": function(a, b) {
        return a - b;
      }
    });
    return throws((function() {
      return upsideDown.adapt(42, upsideDownNumber);
    }), /value.*cannot be adapted/i, "Numbers cannot be adapted in JavaScript, unfortunately.");
  });

  test("Adaptation through delegation", function() {
    var NoisyPerson, Person, bob, noisy;
    Person = {
      greet: function() {
        return 'hello';
      }
    };
    NoisyPerson = Trait({
      greet: function() {
        return 'HELLO';
      }
    });
    noisy = new Context();
    noisy.adapt(Person, NoisyPerson);
    bob = Object.create(Person);
    equal(Person.greet(), 'hello', "Prototype exhibits default behaviour.");
    equal(bob.greet(), 'hello', "Object exhibits prototype behaviour.");
    noisy.activate();
    equal(Person.greet(), 'HELLO', "Prototype exhibits adapted behaviour.");
    equal(bob.greet(), 'HELLO', "Object exhibits behaviour of adapted prototype.");
    noisy.deactivate();
    equal(Person.greet(), 'hello', "Prototype reacts to context deactivation.");
    return equal(bob.greet(), 'hello', "Object exhibits behaviour of readapted prototype.");
  });

  module("Context Composition", {
    setup: function() {
      this.phone = {
        advertise: function() {
          return 'ringtone';
        },
        toString: function() {
          return 'phone';
        }
      };
      this.quiet = new Context('quiet');
      this.quietPhone = Trait({
        advertise: function() {
          return 'vibrator';
        }
      });
      this.screening = new Context('screening');
      return this.screeningPhone = Trait({
        advertise: function() {
          return "" + (this.proceed()) + " with screening";
        }
      });
    }
  });

  test("Composition through proceed", function() {
    this.screening.adapt(this.phone, this.screeningPhone);
    equal(this.phone.advertise(), 'ringtone', "Default behaviour is initially exhibited.");
    this.screening.activate();
    equal(this.phone.advertise(), 'ringtone with screening', "Adapted behaviour is overlaid on top of default behaviour");
    return this.screening.deactivate();
  });

  test("Handling of original arguments in proceed", function() {
    var enthusiasticPerson, party, person;
    person = {
      greet: function(peer) {
        return "Hello " + peer;
      }
    };
    party = new Context('party');
    enthusiasticPerson = Trait({
      greet: function(peer) {
        return this.proceed() + '!';
      }
    });
    party.adapt(person, enthusiasticPerson);
    equal(person.greet('Ken'), 'Hello Ken', "Default behaviour handles parameter as expected.");
    party.activate();
    return equal(person.greet('Ken'), 'Hello Ken!', "Original arguments are passed through by parameter-less proceed invocation.");
  });

  test("Proceed with explicit arguments", function() {
    var atWork, formalPerson, person;
    person = {
      greet: function(peer) {
        return "Hello " + peer;
      }
    };
    atWork = new Context('atWork');
    formalPerson = Trait({
      greet: function(peer) {
        return this.proceed("Mr. " + peer);
      }
    });
    atWork.adapt(person, formalPerson);
    equal(person.greet('Ken'), 'Hello Ken', "Default behaviour handles parameter as expected.");
    atWork.activate();
    return equal(person.greet('Loach'), 'Hello Mr. Loach', "Adapted behaviour takes explicit proceed parameter into account.");
  });

  test("Invalid proceed", function() {
    this.phone.advertise = function() {
      return this.proceed();
    };
    this.screening.adapt(this.phone, this.screeningPhone);
    this.screening.activate();
    return throws((function() {
      return this.phone.advertise();
    }), /cannot proceed further/i, "Cannot proceed from default method.");
  });

  test("Nested activation", function() {
    this.quiet.adapt(this.phone, this.quietPhone);
    this.screening.adapt(this.phone, this.screeningPhone);
    equal(this.phone.advertise(), 'ringtone', "Default behaviour is initially exhibited.");
    this.quiet.activate();
    equal(this.phone.advertise(), 'vibrator', "Adapted behaviour is exhibited after activation of context.");
    this.screening.activate();
    equal(this.phone.advertise(), 'vibrator with screening', "Extended behaviour is overlaid on top of adapted behaviour.");
    this.screening.deactivate();
    equal(this.phone.advertise(), 'vibrator', "Adapted behaviour is exhibited again after deactivation of extended behaviour.");
    this.quiet.deactivate();
    return equal(this.phone.advertise(), 'ringtone', "Behaviour is back to default after deactivation of all contexts.");
  });

  test("Interleaved activation", function() {
    this.quiet.adapt(this.phone, this.quietPhone);
    this.screening.adapt(this.phone, this.screeningPhone);
    this.quiet.activate();
    equal(this.phone.advertise(), 'vibrator', "Adapted behaviour is exhibited after activation of context.");
    this.screening.activate();
    equal(this.phone.advertise(), 'vibrator with screening', "Extended behaviour is overlaid on top of adapted behaviour.");
    this.quiet.deactivate();
    equal(this.phone.advertise(), 'ringtone with screening', "Early deactivation of context is supported.");
    this.screening.deactivate();
    return equal(this.phone.advertise(), 'ringtone', "Behaviour is restored to default.");
  });

  test("Composition with delegation", function() {
    var bobsPhone;
    this.screening.adapt(this.phone, this.screeningPhone);
    bobsPhone = Object.create(this.phone);
    equal(this.phone.advertise(), 'ringtone', 'Prototype exhibits default behaviour.');
    equal(bobsPhone.advertise(), 'ringtone', "Object exhibits prototype behaviour.");
    this.screening.activate();
    equal(this.phone.advertise(), 'ringtone with screening', "Prototype exhibits adapted behaviour.");
    equal(bobsPhone.advertise(), 'ringtone with screening', "Object exhibits behaviour of adapted prototype.");
    this.screening.deactivate();
    equal(this.phone.advertise(), 'ringtone', "Prototype reacts to context deactivation.");
    return equal(bobsPhone.advertise(), 'ringtone', "Object exhibits behaviour of readapted prototype.");
  });

  module("Context Namespaces");

  test("Infrastruture", function() {
    ok(typeof Namespace !== "undefined" && Namespace !== null, "Namespace prototype exists.");
    return ok($.isFunction(Context.prototype.path), "Method for context path retrieval exists.");
  });

  test("Default namespaces", function() {
    return ok(contexts instanceof Namespace, "Root namespace `contexts` exists.");
  });

  test("Context paths", function() {
    var context, name, name2, path;
    context = new Context();
    ok(!context.path(), "Freshly created context does not belong to any namespace.");
    name = makeName();
    contexts[name] = context;
    path = context.path();
    ok(path, "Context in root namespace is effectively found by `path` method.");
    ok($.isArray(path), "Context path is an array.");
    ok(path.every(function(element) {
      return _.isString(element);
    }), "Context path contains only names (strings).");
    deepEqual(path, [name], "A context in the root namespace has a path consisting of only its name.");
    delete contexts[name];
    ok(!context.path(), "Context removed from its namespace is no longer found by `path` method.");
    name2 = makeName();
    contexts[name] = new Namespace(contexts);
    contexts[name][name2] = context;
    deepEqual(context.path(), [name, name2], "Context with path of depth 2 is effectively found.");
    delete contexts[name];
    ok(!context.path(), "Context from trimmed (subtree) namespace is no longer found.");
    return deepEqual(contexts.Default.path(), ["Default"], "Default context detects its path correctly.");
  });

  test("Context name based on path", function() {
    var context;
    context = new Context();
    contexts.a = new Namespace(contexts);
    contexts.a.b = context;
    equal(context.name(), "a.b", "Context name follows path in the `contexts` namespace.");
    delete contexts.a;
    return equal(context.name(), "anonymous", "Context name reverts to anonymous when removed from namespace.");
  });

  asyncTest("Context module loading", function() {
    ok(!((typeof contexts !== "undefined" && contexts !== null ? contexts.platform : void 0) != null), "The platform namespace is initially not loaded.");
    return contexts.load('platform', {
      success: function() {
        ok((typeof contexts !== "undefined" && contexts !== null ? contexts.platform : void 0) != null, "The platform namespace can be loaded.");
        ok(contexts.platform instanceof Namespace, "Loaded object is namespace.");
        return start();
      },
      failure: function(error) {
        ok(false, "Failed to load platform namespace: " + error);
        return start();
      }
    });
  });

  module("Context Library");

}).call(this);
